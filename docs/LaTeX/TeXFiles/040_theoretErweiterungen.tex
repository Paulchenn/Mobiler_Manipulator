\chapter{Theoretische Konzepte und Erweiterungen}
\label{ch:theorie}

Dieser Abschnitt behandelt weiterführende Fragestellungen der Roboterbahnplanung, die über die Implementierung des planaren Manipulators hinausgehen. Gemäß der Aufgabenstellung werden im Folgenden die notwendigen Systemerweiterungen für translatorische Gelenke sowie Methoden zur nachträglichen Bahnoptimierung diskutiert.





\section{Erweiterung um translatorische Gelenke}
Das in dieser Arbeit betrachtete System besteht aus einer mobilen Basis (3 Freiheitsgrade) und einem Arm mit rotatorischen Gelenken (Revolute Joints). Ein translatorisches Gelenk (Prisma-Gelenk) ermöglicht hingegen eine lineare Relativbewegung zwischen zwei Segmenten, was sowohl den Arbeitsraum als auch die kinematische Modellierung beeinflusst \cite{siciliano2016}.




\subsection{Auswirkung auf die Kinematik}
In der Vorwärtskinematik wird die Lage eines Segments relativ zum vorherigen Segment üblicherweise durch homogene Transformationsmatrizen $T$ beschrieben. 

Für ein \textbf{rotatorisches Gelenk} rotiert das lokale Koordinatensystem um die Gelenkachse (z.\,B. z-Achse) um den variablen Winkel $\theta$. Die Matrix hat die Form:
\begin{equation}
    T_{rot}(\theta) = \begin{bmatrix}
    \cos\theta & -\sin\theta & 0 & 0 \\
    \sin\theta & \cos\theta & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
    \end{bmatrix}
\end{equation}

Für ein \textbf{translatorisches Gelenk} ist die Rotation statisch, während die Verschiebung $d$ entlang der Gelenkachse variabel ist. Die Transformationsmatrix ändert sich folglich zu:
\begin{equation}
    T_{trans}(d) = \begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & d \\
    0 & 0 & 0 & 1
    \end{bmatrix}
\end{equation}

\newpage

\textbf{Implementierungstechnische Konsequenzen:}
Für die Integration in den bestehenden \texttt{CollisionChecker} müsste die Methode zur Berechnung der Robotergeometrie (\texttt{get\_robot\_geometry}) angepasst werden. Anstatt für jedes Gelenk den Winkel zu akkumulieren, müsste für Prisma-Gelenke die effektive Länge des Segments dynamisch berechnet werden. Das Gelenk $q_i$ würde direkt als Längenänderung in die Berechnung der Endpunktkoordinaten eingehen.




\subsection{Anpassung des Konfigurationsraums (C-Space)}
Die Einführung translatorischer Freiheitsgrade verändert die Topologie und die Metrik des Konfigurationsraums \cite{lavalle2006}:
\begin{itemize}
    \item \textbf{Wertebereich und Topologie:} Während rotatorische Gelenke meist periodisch definiert sind ($-\pi$ bis $\pi$), sind translatorische Gelenke durch feste mechanische Anschläge begrenzt ($d_{min}$ bis $d_{max}$). Mathematisch betrachtet ändert sich die Topologie des Gelenks von einem Kreis ($S^1$)\footnote{Die Topologie $S^1$ (1-Sphäre) beschreibt einen kreisförmigen Raum, bei dem die Werte periodisch umlaufen, d.\,h. $-\pi$ und $\pi$ sind identisch.} zu einer Linie ($\mathbb{R}$).
    \item \textbf{Sampling und Metrik:} Wie bereits bei der mobilen Basis ($x, y$ in \ac{LE}, $\theta$ in Radiant), liegen auch bei einem Arm mit translatorischen Gelenken gemischte Einheiten vor. Dies stellt besondere Anforderungen an die Distanzfunktion (Metrik) für die \textit{Nearest-Neighbor}-Suche. Da eine Differenz von $1\,\text{\ac{LE}}$ nicht äquivalent zu $1\,\text{rad}$ ist, muss zwingend eine \textbf{gewichtete Euklidische Metrik} verwendet werden. Hierbei werden die translatorischen und rotatorischen Dimensionen mit Gewichtungsfaktoren $w_i$ skaliert, um einen homogenen Abstandsraum zu schaffen.
\end{itemize}

% \newpage





\section{Optimierung und Glättung von Bewegungsbahnen}
Die von Sampling-basierten Algorithmen erzeugten Pfade bestehen naturgemäß aus linearen Segmenten zwischen zufällig platzierten Wegpunkten. Dies resultiert oft in \enquote{zackigen}, suboptimalen Bahnen mit abrupten Richtungsänderungen. Eine Nachbearbeitung (Post-Processing) ist daher essenziell \cite{choset2005}.




\subsection{Shortcut-Methode (Pruning)}
Ein effizienter Ansatz zur Reduktion der Pfadlänge ist die heuristische Shortcut-Methode. Dieser Algorithmus arbeitet iterativ auf dem initialen diskreten Pfad:

\begin{enumerate}
    \item Es werden zwei zufällige Konfigurationen $q_a$ und $q_b$ auf dem Pfad ausgewählt, die nicht direkt benachbart sind.
    \item Es wird geprüft, ob die direkte Verbindungslinie (Line-of-Sight) im Konfigurationsraum zwischen $q_a$ und $q_b$ kollisionsfrei ist.
    \item Ist die Verbindung valide, werden alle dazwischenliegenden Wegpunkte entfernt und durch die direkte Kante ersetzt.
\end{enumerate}
Das Ergebnis ist ein stückweise linearer Pfad. Dieser ist zwar kürzer, bleibt jedoch lediglich $C^0$-stetig\footnote{$C^0$-Stetigkeit bedeutet, dass der Pfad zusammenhängend ist (keine Sprünge in der Position), aber Knicke aufweist. An diesen Knicken ist die Geschwindigkeit unstetig (der Roboter müsste theoretisch anhalten, um die Richtung zu ändern).}, was zu mechanisch ungünstigen Stopp-and-Go-Bewegungen an den Wegpunkten führt.




\subsection{Glättung mittels Splines}
Um eine kinematisch hochwertige Bahn zu generieren, können die Wegpunkte des optimierten Pfades durch Spline-Kurven approximiert werden. Ziel ist hierbei oft $C^2$-Stetigkeit\footnote{$C^2$-Stetigkeit bedeutet, dass nicht nur die Position und die Geschwindigkeit ($C^1$), sondern auch die Beschleunigung stetig verläuft. Dies ermöglicht ruckfreie Bewegungen.}.

\begin{itemize}
    \item \textbf{B-Splines:} Die Wegpunkte des \ac{PRM}-Pfades dienen hierbei als Kontrollpunkte. Der resultierende Spline verläuft nicht zwingend durch die Punkte, sondern wird von ihnen approximiert. Dies garantiert einen glatten Verlauf, birgt jedoch das Risiko, dass die Kurve Hindernisse schneidet (\enquote{Corner Cutting}).
    \item \textbf{Validierung:} Nach der Spline-Generierung muss die Kurve diskretisiert und erneut auf Kollisionsfreiheit geprüft werden. Sollten Kollisionen auftreten, können iterative Verfahren (z.\,B. Einfügen zusätzlicher Stützpunkte) angewandt werden, um den Pfad lokal zu deformieren und in den freien Raum zurückzuführen.
\end{itemize}

Eine Kombination aus der Shortcut-Methode für die globale Optimierung und anschließender Spline-Interpolation für die lokale Glättung stellt den Stand der Technik für mobile Manipulatoren dar.





\section{Weitere Erweiterungsmöglichkeiten}
Neben den theoretischen Konzepten zur Kinematik und Bahnoptimierung ergeben sich aus den Evaluationen (Kapitel~\ref{ch:evaluation} und~\ref{ch:pickplace}) konkrete Ansätze zur Verbesserung der implementierten Softwarearchitektur und der Planungsstrategien.

\subsection{Optimierung der Kollisionsprüfung}
Wie in Abschnitt~\ref{sec:quantitative_results} (\nameref{sec:quantitative_results}) beschrieben, kann die Reihenfolge der Prüfungen im \textit{CollisionChecker} optimiert werden. Da die Eigenkollisionsprüfung (\textit{Self-Collision}) bedeutend weniger Rechenzeit benötigt als die Sichtbarkeitsprüfung gegen externe Hindernisse, sollte diese vorgezogen werden. Es ist ineffizient, aufwendige Raycasts durchzuführen, wenn die Konfiguration bereits aufgrund einer internen Kollision ungültig ist.

\subsection{Zeit-normalisiertes Benchmarking}
Um die Leistungsfähigkeit der Planer fairer zu vergleichen, könnte ein \textit{Time-Budget}-Ansatz gewählt werden. Dabei erhalten beide Planer (\ac{LazyPRM} und \ac{VisibilityPRM}) exakt die gleiche Rechenzeit. Die Parameter der Planer werden so angepasst, dass sie dieses Zeitfenster optimal nutzen. Anschließend wird die Erfolgsrate (\textit{Success Rate}) als primäres Vergleichskriterium ausgewertet.

\subsection{Entkoppelte Planung}
Zur Steigerung der Geschwindigkeit und Qualität kann die Planung hierarchisch entkoppelt werden. Im ersten Schritt wird lediglich ein Pfad für die Basis ($x, y, \theta_\text{base}$) geplant, während die Armgelenke ($\theta_\text{1}, \theta_\text{2}$) in einer starren Transportkonfiguration verbleiben. Erst in der unmittelbaren Umgebung einer Pick- oder Place-Aktion wird der volle 5-dimensionale Konfigurationsraum betrachtet, um die notwendigen Armbewegungen zu planen.

\subsection{Heuristisches Sampling für LazyPRM}
Der aktuelle \ac{LazyPRM} verteilt neue Punkte in nachfolgenden Iterationen gleichverteilt über den gesamten Raum. Eine effizientere Strategie wäre es, diese Punkte gezielt an Engstellen zu platzieren. Dies kann beispielsweise dadurch erreicht werden, dass bevorzugt in der Nähe von Konfigurationen gesampelt wird, an denen zuvor unzulässige Kanten oder Knoten detektiert wurden, um so kritische Bereiche im Graphen gezielt aufzulösen.